<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Data Converter Tool</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f7f7f7;
    margin: 0;
    padding: 20px;
  }
  h1 {
    text-align: center;
  }
  textarea {
    width: 100%;
    height: 200px;
    margin-top: 10px;
    font-family: monospace;
    font-size: 14px;
    padding: 10px;
    box-sizing: border-box;
  }
  .controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 10px;
  }
  button {
    padding: 10px 15px;
    background-color: #0078d7;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }
  button:hover {
    background-color: #005fa3;
  }
  #output {
    background: white;
    border: 1px solid #ccc;
    padding: 10px;
    margin-top: 10px;
    overflow: auto;
    max-height: 400px;
    white-space: pre-wrap;
    font-family: monospace;
  }
  .tree ul {
    list-style-type: none;
    padding-left: 20px;
    margin: 0;
  }
  .tree li {
    position: relative;
    cursor: pointer;
    padding-left: 14px;
  }
  .tree li::before {
    content: "▶";
    position: absolute;
    left: 0;
    top: 0;
    color: #666;
    font-size: 12px;
  }
  .tree li.open::before {
    content: "▼";
  }
  .tree li.leaf::before {
    content: "";
  }
  .hidden {
    display: none;
  }
</style>
</head>
<body>
  <h1>Data Converter</h1>
  <textarea id="input" placeholder="Paste JSON, XML, or CSV data here..."></textarea>

  <div class="controls">
    <button onclick="convertTo('json')">To JSON</button>
    <button onclick="convertTo('xml')">To XML</button>
    <button onclick="convertTo('csv')">To CSV</button>
    <button onclick="showTree()">Tree</button>
    <button onclick="validateIndent()">Validate / Indent</button>
    <button onclick="downloadFile()">Download</button>
  </div>

  <div id="output"></div>

<script>
let currentFormat = '';

function detectFormat(text) {
  text = text.trim();
  if (text.startsWith('{') || text.startsWith('[')) return 'json';
  if (text.startsWith('<')) return 'xml';
  if (text.includes(',') && text.includes('\n')) return 'csv';
  return 'unknown';
}

function convertTo(format) {
  const input = document.getElementById('input').value.trim();
  let result = '';
  try {
    const inputFormat = detectFormat(input);
    let data;

    // Convert input to JSON object first
    if (inputFormat === 'json') data = JSON.parse(input);
    else if (inputFormat === 'xml') data = xmlToJson(new DOMParser().parseFromString(input, 'text/xml'));
    else if (inputFormat === 'csv') data = csvToJson(input);
    else throw new Error('Unrecognized input format.');

    // Convert JSON object to desired output format
    if (format === 'json') result = JSON.stringify(data, null, 2);
    else if (format === 'xml') result = jsonToXml(data);
    else if (format === 'csv') result = jsonToCsv(data);

    document.getElementById('output').textContent = result;
    currentFormat = format;
  } catch (e) {
    document.getElementById('output').textContent = 'Error: ' + e.message;
  }
}

function validateIndent() {
  const input = document.getElementById('input').value.trim();
  try {
    const format = detectFormat(input);
    let data;
    if (format === 'json') {
      data = JSON.parse(input);
      document.getElementById('output').textContent = JSON.stringify(data, null, 2);
      currentFormat = 'json';
    } else if (format === 'xml') {
      const parser = new DOMParser();
      const xml = parser.parseFromString(input, 'application/xml');
      const serializer = new XMLSerializer();
      const formatted = serializer.serializeToString(xml).replace(/></g, '>\n<');
      document.getElementById('output').textContent = formatted;
      currentFormat = 'xml';
    } else if (format === 'csv') {
      data = csvToJson(input);
      document.getElementById('output').textContent = jsonToCsv(data);
      currentFormat = 'csv';
    } else {
      document.getElementById('output').textContent = 'Unknown format.';
    }
  } catch (e) {
    document.getElementById('output').textContent = 'Invalid data: ' + e.message;
  }
}

function showTree() {
  const input = document.getElementById('input').value.trim();
  try {
    const format = detectFormat(input);
    let data;
    if (format === 'json') data = JSON.parse(input);
    else if (format === 'xml') data = xmlToJson(new DOMParser().parseFromString(input, 'text/xml'));
    else if (format === 'csv') data = csvToJson(input);
    else throw new Error('Unknown format');

    const tree = document.createElement('div');
    tree.className = 'tree';
    tree.appendChild(buildTree(data));

    const output = document.getElementById('output');
    output.innerHTML = '';
    output.appendChild(tree);
  } catch (e) {
    document.getElementById('output').textContent = 'Error: ' + e.message;
  }
}

function buildTree(obj) {
  const ul = document.createElement('ul');
  for (let key in obj) {
    const li = document.createElement('li');
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      li.textContent = key;
      li.appendChild(buildTree(obj[key]));
    } else {
      li.textContent = key + ': ' + obj[key];
      li.classList.add('leaf');
    }
    ul.appendChild(li);
  }

  // Make collapsible
  ul.querySelectorAll(':scope > li:not(.leaf)').forEach(li => {
    const childUl = li.querySelector('ul');
    if (childUl) {
      childUl.classList.add('hidden');
      li.addEventListener('click', e => {
        e.stopPropagation();
        li.classList.toggle('open');
        childUl.classList.toggle('hidden');
      });
    }
  });

  return ul;
}

function xmlToJson(xml) {
  if (xml.nodeType === 3) return xml.nodeValue.trim();
  const obj = {};
  if (xml.attributes && xml.attributes.length > 0) {
    obj['@attributes'] = {};
    for (let j = 0; j < xml.attributes.length; j++) {
      const attr = xml.attributes.item(j);
      obj['@attributes'][attr.nodeName] = attr.nodeValue;
    }
  }
  if (xml.hasChildNodes()) {
    for (let i = 0; i < xml.childNodes.length; i++) {
      const item = xml.childNodes.item(i);
      const nodeName = item.nodeName;
      const val = xmlToJson(item);
      if (val !== '') {
        if (obj[nodeName] === undefined) obj[nodeName] = val;
        else {
          if (!Array.isArray(obj[nodeName])) obj[nodeName] = [obj[nodeName]];
          obj[nodeName].push(val);
        }
      }
    }
  }
  return obj;
}

function jsonToXml(obj, indent = '') {
  let xml = '';
  for (let prop in obj) {
    if (prop === '@attributes') continue;
    const value = obj[prop];
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        xml += indent + '<' + prop + jsonAttributes(obj['@attributes']) + '>\n';
        xml += jsonToXml(value[i], indent + '  ');
        xml += indent + '</' + prop + '>\n';
      }
    } else if (typeof value === 'object') {
      xml += indent + '<' + prop + jsonAttributes(obj['@attributes']) + '>\n';
      xml += jsonToXml(value, indent + '  ');
      xml += indent + '</' + prop + '>\n';
    } else {
      xml += indent + '<' + prop + '>' + value + '</' + prop + '>\n';
    }
  }
  return xml;
}

function jsonAttributes(attrs) {
  if (!attrs) return '';
  return ' ' + Object.entries(attrs).map(([k, v]) => `${k}="${v}"`).join(' ');
}

function csvToJson(csv) {
  const lines = csv.split('\n').filter(l => l.trim() !== '');
  const headers = lines[0].split(',');
  const result = [];
  for (let i = 1; i < lines.length; i++) {
    const obj = {};
    const currentline = lines[i].split(',');
    for (let j = 0; j < headers.length; j++) obj[headers[j]] = currentline[j];
    result.push(obj);
  }
  return result;
}

function jsonToCsv(json) {
  const array = Array.isArray(json) ? json : [json];
  const headers = Object.keys(array[0]);
  const csv = [headers.join(',')];
  array.forEach(obj => csv.push(headers.map(h => obj[h]).join(',')));
  return csv.join('\n');
}

function downloadFile() {
  const text = document.getElementById('output').textContent;
  let blob, filename;
  if (currentFormat === 'json') {
    blob = new Blob([text], { type: 'application/json' });
    filename = 'data.json';
  } else if (currentFormat === 'xml') {
    blob = new Blob([text], { type: 'application/xml' });
    filename = 'data.xml';
  } else if (currentFormat === 'csv') {
    blob = new Blob([text], { type: 'text/csv' });
    filename = 'data.csv';
  } else {
    blob = new Blob([text], { type: 'text/plain' });
    filename = 'data.txt';
  }
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}
</script>
</body>
</html>
